<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üéôÔ∏è MELO Voice Cloner</title>
  <link rel="stylesheet" href="styles1.css" />
</head>

<body>
  <div class="container">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h2 class="sidebar-title">üéôÔ∏è MELO Voice Cloner</h2>
      </div>
      <div class="input-group">
        <label for="language" class="input-label">üåê Language</label>
        <select id="language" class="select-input">
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="it">Italian</option>
          <option value="pt">Portuguese</option>
          <option value="pl">Polish</option>
          <option value="tr">Turkish</option>
          <option value="ru">Russian</option>
          <option value="nl">Dutch</option>
          <option value="cs">Czech</option>
          <option value="ar">Arabic</option>
          <option value="zh-cn">Chinese</option>
          <option value="ja">Japanese</option>
          <option value="hu">Hungarian</option>
          <option value="ko">Korean</option>
          <option value="hi">Hindi</option>
        </select>
      </div>
      <div class="input-group">
        <label for="refAudio" class="input-label" data-tooltip="Upload a sample of the voice you want to clone">üîº
          Reference Audio</label>
        <input type="file" id="refAudio" accept="audio/*" required class="file-input" />
      </div>
      <div class="input-group">
        <label for="modeSelect" class="input-label" data-tooltip="Choose how you want to use the voice cloning">üß†
          Mode</label>
        <select id="modeSelect" class="select-input">
          <option value="text">Clone My Text</option>
          <option value="clone-my-audio">Clone My Audio</option>
          <option value="llmText">Ask LLM (Text)</option>
          <option value="llmAudio">Ask LLM (Audio)</option>
        </select>
      </div>
    </aside>
    <main class="main">
      <div class="card">
        <div class="card-header">
          <h1 class="card-title">üéôÔ∏è MELO AI Voice Cloner</h1>
          <p class="card-subtitle">Transform your voice into a digital masterpiece ‚Äî Clone it with cutting-edge AI
            models</p>
        </div>
        <form id="voiceForm" class="form">
          <div id="textInputContainer">
            <label for="userText" class="input-label">‚úçÔ∏è Enter Text or Question</label>
            <textarea id="userText" class="textarea"
              placeholder="Write something here that you want to hear in your cloned voice..."></textarea>
          </div>
          <div id="recordContainer" class="hidden">
            <label class="input-label">üé§ Record Your Question</label>
            <button type="button" id="recordBtn" class="record-btn">
              <span id="recordBtnText">Start Recording</span>
            </button>
            <p id="recordStatus" class="record-status"></p>
            <div id="audioVisualizer" class="hidden">
              <canvas id="visualizer" width="300" height="60"></canvas>
            </div>
          </div>
          <div id="spinner" class="spinner hidden"></div>
          <button type="submit" class="submit-btn">üöÄ Generate Cloned Voice</button>
        </form>
        <div id="output" class="output hidden">
          <h2 class="output-title">üéß Generated Voice</h2>
          <audio id="audioPlayer" controls class="audio-player"></audio>
          <a id="downloadBtn" class="download-btn" download="melo-cloned-voice.wav">‚¨áÔ∏è Download Cloned Audio</a>
          <p id="errorMessage" class="error-message hidden"></p>
        </div>
      </div>
    </main>
  </div>
  <script>
    // Configuration
    const BASE_URL = 'http://localhost:8000';
    const POLL_INTERVAL = 5000; // Poll every 5 seconds

    // DOM Elements
    const modeSelect = document.getElementById('modeSelect');
    const textInputContainer = document.getElementById('textInputContainer');
    const recordContainer = document.getElementById('recordContainer');
    const recordBtn = document.getElementById('recordBtn');
    const recordBtnText = document.getElementById('recordBtnText');
    const recordStatus = document.getElementById('recordStatus');
    const voiceForm = document.getElementById('voiceForm');
    const spinner = document.getElementById('spinner');
    const output = document.getElementById('output');
    const downloadBtn = document.getElementById('downloadBtn');
    const audioPlayer = document.getElementById('audioPlayer');
    const errorMessage = document.getElementById('errorMessage');
    const visualizer = document.getElementById('visualizer');
    const audioVisualizer = document.getElementById('audioVisualizer');
    const refAudio = document.getElementById('refAudio');
    const userText = document.getElementById('userText');
    const languageSelect = document.getElementById('language');

    // State Variables
    let recordedBlob = null;
    let mediaRecorder = null;
    let audioContext = null;
    let analyser = null;
    let isRecording = false;
    let animationFrame = null;
    let stream = null;

    // Function to send logs to the backend
    async function sendLogToBackend(message) {
      try {
        const response = await fetch(`${BASE_URL}/log-frontend-message`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ message }),
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
      } catch (err) {
        console.error(`[${new Date().toISOString()}] Failed to send log to backend:`, err);
      }
    }

    // Prevent form refresh
    voiceForm.setAttribute('novalidate', 'novalidate');

    // Mode selection handler
    modeSelect.addEventListener('change', async () => {
      const selected = modeSelect.value;
      textInputContainer.classList.toggle('hidden', selected === 'clone-my-audio' || selected === 'llmAudio');
      recordContainer.classList.toggle('hidden', selected !== 'clone-my-audio' && selected !== 'llmAudio');
      output.classList.add('hidden');
      audioPlayer.src = '';
      audioPlayer.style.display = 'none';
      downloadBtn.style.display = 'none';
      errorMessage.classList.add('hidden');
      const timestamp = new Date().toISOString();
      await sendLogToBackend(`[${timestamp}] Mode changed to: ${selected}`);
    });

    // Audio visualizer initialization
    function initAudioVisualizer(stream) {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const ctx = visualizer.getContext('2d');

        function draw() {
          if (!isRecording) return;
          animationFrame = requestAnimationFrame(draw);
          analyser.getByteFrequencyData(dataArray);
          ctx.clearRect(0, 0, visualizer.width, visualizer.height);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.fillRect(0, 0, visualizer.width, visualizer.height);
          const barWidth = (visualizer.width / bufferLength) * 2.5;
          let x = 0;
          for (let i = 0; i < bufferLength; i++) {
            const barHeight = dataArray[i] / 2;
            ctx.fillStyle = `rgb(245, ${197 + i}, ${24 + i})`;
            ctx.fillRect(x, visualizer.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
          }
        }
        draw();
      } catch (err) {
        const timestamp = new Date().toISOString();
        sendLogToBackend(`[${timestamp}] Visualizer error: ${err.message}`);
        audioVisualizer.classList.add('hidden');
      }
    }

    // Recording handler
    async function toggleRecording() {
      const timestamp = new Date().toISOString();
      if (isRecording) {
        isRecording = false;
        recordBtnText.textContent = 'Start Recording';
        recordBtn.classList.remove('recording');
        recordStatus.textContent = '‚úÖ Recording complete.';
        if (mediaRecorder) mediaRecorder.stop();
        if (stream) stream.getTracks().forEach(track => track.stop());
        if (animationFrame) cancelAnimationFrame(animationFrame);
        audioVisualizer.classList.add('hidden');
        await sendLogToBackend(`[${timestamp}] Recording stopped`);
      } else {
        try {
          await sendLogToBackend(`[${timestamp}] Starting recording...`);
          recordStatus.textContent = 'üéôÔ∏è Recording... speak now.';
          recordBtnText.textContent = 'Stop Recording';
          recordBtn.classList.add('recording');
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const chunks = [];
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/wav' });
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          mediaRecorder.onstop = async () => {
            recordedBlob = new Blob(chunks, { type: 'audio/wav' });
            await sendLogToBackend(`[${timestamp}] Recorded blob size: ${recordedBlob.size} bytes`);
          };
          mediaRecorder.start();
          isRecording = true;
          audioVisualizer.classList.remove('hidden');
          initAudioVisualizer(stream);
          setTimeout(() => {
            if (isRecording) toggleRecording();
          }, 10000);
          await sendLogToBackend(`[${timestamp}] Recording started`);
        } catch (err) {
          await sendLogToBackend(`[${timestamp}] Recording error: ${err.message}`);
          recordStatus.textContent = '‚ùå Error accessing microphone.';
          showNotification('Microphone access failed.', 'error');
        }
      }
    }

    // Poll status until task is completed
    async function pollStatus(taskId, outputFilename) {
      const timestamp = new Date().toISOString();
      try {
        const response = await fetch(`${BASE_URL}/status/${taskId}`);
        if (!response.ok) {
          throw new Error(`Status check failed: ${response.statusText}`);
        }
        const statusData = await response.json();
        await sendLogToBackend(`[${timestamp}] Task ${taskId} status: ${statusData.status}`);

        if (statusData.status === "completed") {
          // Fetch the audio file
          const audioResponse = await fetch(`${BASE_URL}/get-audio/${taskId}`);
          if (!audioResponse.ok) {
            throw new Error(`Failed to fetch audio: ${audioResponse.statusText}`);
          }
          const blob = await audioResponse.blob();
          await sendLogToBackend(`[${timestamp}] Fetched generated voice for task ${taskId}, blob size: ${blob.size} bytes, type: ${blob.type}`);

          const audioUrl = URL.createObjectURL(blob);
          audioPlayer.src = audioUrl;
          audioPlayer.style.display = 'block';
          downloadBtn.href = audioUrl;
          downloadBtn.download = outputFilename;
          downloadBtn.style.display = 'inline-block';
          output.classList.remove('hidden');
          await sendLogToBackend(`[${timestamp}] Generated voice loaded successfully into audio player`);
          audioPlayer.play().catch(async (err) => {
            await sendLogToBackend(`[${timestamp}] Autoplay blocked: ${err.message}`);
            showNotification('Tap play to listen to the generated voice.', 'info');
          });
          showNotification('Voice cloned successfully!', 'success');
          return true;
        } else if (statusData.status === "failed") {
          throw new Error(statusData.error || 'Voice generation failed');
        } else {
          // Continue polling
          return false;
        }
      } catch (error) {
        await sendLogToBackend(`[${timestamp}] Error polling status for task ${taskId}: ${error.message}`);
        throw error;
      }
    }

    // Form submission handler
    voiceForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const timestamp = new Date().toISOString();
      await sendLogToBackend(`[${timestamp}] Initiating request for voice cloning`);

      // Validate inputs
      if (!refAudio.files[0]) {
        await sendLogToBackend(`[${timestamp}] Validation failed: No reference audio file`);
        showNotification('Reference audio is required.', 'error');
        return;
      }

      const formData = new FormData();
      const language = languageSelect.value;
      const mode = modeSelect.value;
      const filename = `ref_audio_${language}_${timestamp.replace(/[:.]/g, '-')}.wav`;
      formData.append('refAudio', refAudio.files[0], filename);
      formData.append('language', language);
      const outputFilename = `cloned_${mode}_${language}_${timestamp.replace(/[:.]/g, '-')}.wav`;
      formData.append('outputFilename', outputFilename);

      let url;
      if (mode === 'text' || mode === 'llmText') {
        if (!userText.value.trim()) {
          await sendLogToBackend(`[${timestamp}] Validation failed: No user text`);
          showNotification('Please enter text.', 'error');
          return;
        }
        formData.append('userText', userText.value);
        url = mode === 'text' ? `${BASE_URL}/clone-text/` : `${BASE_URL}/clone-llm-text/`;
        await sendLogToBackend(`[${timestamp}] Received request for /${mode === 'text' ? 'clone-text' : 'clone-llm-text'}/ with userText: ${userText.value.slice(0, 50)}..., language: ${language}`);
      } else {
        if (!recordedBlob) {
          await sendLogToBackend(`[${timestamp}] Validation failed: No recorded audio`);
          showNotification('Please record audio first.', 'error');
          return;
        }
        formData.append('audioFileInput', recordedBlob, `input_audio_${language}_${timestamp.replace(/[:.]/g, '-')}.wav`);
        url = mode === 'clone-my-audio' ? `${BASE_URL}/clone-my-audio/` : `${BASE_URL}/clone-llm-audio/`;
        await sendLogToBackend(`[${timestamp}] Received request for /${mode === 'clone-my-audio' ? 'clone-my-audio' : 'clone-llm-audio'}/ with language: ${language}`);
      }

      // Show spinner and disable form
      await sendLogToBackend(`[${timestamp}] Showing spinner and disabling form`);
      spinner.classList.remove('hidden');
      voiceForm.querySelector('button[type="submit"]').disabled = true;
      output.classList.add('hidden');
      audioPlayer.src = '';
      audioPlayer.style.display = 'none';
      downloadBtn.style.display = 'none';
      errorMessage.classList.add('hidden');
      await sendLogToBackend(`[${timestamp}] Sending request to: ${url}`);
      for (let [key, value] of formData.entries()) {
        await sendLogToBackend(`[${timestamp}] FormData [${key}]: ${value instanceof File ? value.name : value}`);
      }

      try {
        // Start the task
        const response = await fetch(url, {
          method: 'POST',
          body: formData,
        });
        if (!response.ok) {
          const errorText = await response.text();
          await sendLogToBackend(`[${timestamp}] Backend error: ${errorText}`);
          throw new Error(`Failed to start task: ${errorText}`);
        }
        const taskData = await response.json();
        const taskId = taskData.task_id;
        await sendLogToBackend(`[${timestamp}] Task started with ID: ${taskId}`);

        // Poll for status
        let isCompleted = false;
        while (!isCompleted) {
          isCompleted = await pollStatus(taskId, outputFilename);
          if (!isCompleted) {
            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
          }
        }
      } catch (error) {
        await sendLogToBackend(`[${timestamp}] Error: ${error.message}`);
        output.classList.remove('hidden');
        errorMessage.textContent = `Failed: ${error.message}`;
        errorMessage.classList.remove('hidden');
        showNotification(error.message, 'error');
      } finally {
        await sendLogToBackend(`[${timestamp}] Hiding spinner and re-enabling form`);
        spinner.classList.add('hidden');
        voiceForm.querySelector('button[type="submit"]').disabled = false;
      }
    });

    // Record button handler
    recordBtn.addEventListener('click', toggleRecording);

    // Notification helper
    async function showNotification(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.className = `notification ${type}`;
      const icon = document.createElement('span');
      icon.textContent = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
      notification.prepend(icon);
      document.body.appendChild(notification);
      notification.style.opacity = '1';
      notification.style.transition = 'all 0.3s ease';
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 4000);
      await sendLogToBackend(`[${timestamp}] Notification: ${message} (${type})`);
    }
  </script>
</body>

</html>